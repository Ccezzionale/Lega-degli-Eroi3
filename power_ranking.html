<!DOCTYPE html>
<html lang="it">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Statistiche – Power Ranking</title>
  <style>
    :root{ --bg:#fff; --fg:#0b3d91; --muted:#eef3ff; --card:#f8fbff; --border:#dce6ff; }
    *{ box-sizing:border-box }
    body{ margin:0; font-family:system-ui,Segoe UI,Roboto,Arial,sans-serif; background:var(--bg); color:#0a1a2a }
    header{ position:sticky; top:0; background:linear-gradient(180deg,#fff 0%,#f5f9ff 100%); border-bottom:1px solid var(--border); padding:12px 16px }
    h1{ margin:0; font-size:20px; color:var(--fg) }
    .container{ max-width:1100px; margin:20px auto; padding:0 16px }
    .config{ background:var(--card); border:1px solid var(--border); padding:10px; border-radius:10px; font-size:12px; color:#415a77 }
    .toolbar{ display:flex; gap:8px; align-items:center; margin:16px 0; flex-wrap:wrap }
    .toolbar input[type="url"]{ flex:1; min-width:280px; padding:8px 10px; border:1px solid var(--border); border-radius:8px }
    select{ padding:6px 10px; border:1px solid var(--border); border-radius:8px }
    button{ padding:8px 12px; border:1px solid var(--fg); background:#fff; color:var(--fg); border-radius:10px; cursor:pointer }
    button:hover{ background:var(--muted) }
    table{ width:100%; border-collapse:separate; border-spacing:0 8px }
    th,td{ text-align:left; padding:10px 12px }
    thead th{ font-size:12px; color:#2b4c7e; border-bottom:1px solid var(--border) }
    tbody tr{ background:var(--card); border:1px solid var(--border) }
    .rank{ font-weight:700; color:var(--fg) }
    .team{ font-weight:600 }
    .delta{ font-weight:700 }
    .delta.up{ color:#2e7d32 }
    .delta.down{ color:#c62828 }
    .score,.sub{ font-variant-numeric:tabular-nums }
    .sub{ font-size:12px; color:#415a77 }
    .footer-note{ margin-top:10px; font-size:12px; color:#5a6f8a }

    /* mini-stili per le sottotabelle */
    .subtable { width:100%; border-collapse:separate; border-spacing:0 6px; margin:10px 0 18px }
    .subtable th, .subtable td { padding:8px 10px; text-align:left; font-size:13px }
    .subtable thead th { color:#2b4c7e; border-bottom:1px solid var(--border) }
    .subtable tbody tr { background:var(--card); border:1px solid var(--border) }
    .badge { display:inline-block; font-size:11px; padding:2px 6px; border:1px solid var(--border); border-radius:999px; color:#335; margin:6px 0 }
  </style>
</head>
<body>
<header><h1>Power Ranking</h1></header>
<div class="container">
  <div class="config">
    <strong>CONFIG</strong>
    <div>Incolla l’URL CSV pubblicato del tab <code>Risultati PR – Tutte</code>, oppure imposta <code>DEFAULT_CSV_URL</code> nello script.</div>
  </div>

  <div class="toolbar">
    <input id="csvUrl" type="url" placeholder="https://docs.google.com/spreadsheets/d/e/.../pub?output=csv" />
    <select id="phase">
      <option value="">Tutte le fasi</option>
      <option value="Regular">Regular</option>
      <option value="Playoff">Playoff</option>
    </select>
    <button id="loadBtn">Carica / Aggiorna</button>
  </div>

  <div id="meta" class="sub"></div>

  <table>
    <thead>
      <tr>
        <th>#</th>
        <th>Squadra</th>
        <th>Score</th>
        <th>Trend</th>
        <th>Media (stag.)</th>
        <th>Forma (ult.5)</th>
        <th>Consistenza</th>
      </tr>
    </thead>
    <tbody id="tbody"></tbody>
  </table>

  <div class="footer-note">
    <strong>Come si calcola lo Score</strong> — <em>0–100</em> come media pesata di:
    50% <u>Forma</u> (media punti ultime 5), 30% <u>Media stagionale</u> (media di tutte le giornate),
    20% <u>Consistenza</u> (regolarità: meno oscillazioni nelle ultime 5 ⇒ valore più alto). All’inizio la Media pesa di più.
  </div>
  <div id="diag" class="footer-note"></div>

  <!-- Sezioni extra -->
  <h2 style="margin-top:28px;">Hall of Shame</h2>
  <div id="shame-worst"></div>
  <div id="shame-lowwins"></div>
  <div id="shame-highloss"></div>

  <h2 style="margin-top:28px;">Lucky / Unlucky (mediana di giornata)</h2>
  <div id="luck-most"></div>

  <h2 style="margin-top:28px;">Statistiche curiose</h2>
  <div id="fun-facts"></div>
</div>

<script>
/** Caricamento automatico: metti qui l’URL del CSV */
const DEFAULT_CSV_URL = "https://docs.google.com/spreadsheets/d/e/2PACX-1vRhEJKfZhVb7V08KI29T_aPTR0hfx7ayIOlFjQn_v-fqgktImjXFg-QAEA6z7w5eyEh2B3w5KLpaRYz/pub?gid=595956835&single=true&output=csv";

async function fetchCSV(url){
  const res = await fetch(url, { cache: 'no-store' });
  if(!res.ok) throw new Error('Errore fetch CSV');
  const text = await res.text();
  return parseCSV(text);
}

// CSV robusto: gestisce virgolette, virgole decimali, CRLF
function parseCSV(text){
  const rows = [];
  let field = "", row = [], inQuotes = false;

  for (let i = 0; i < text.length; i++){
    const c = text[i];
    if (c === '"'){
      if (inQuotes && text[i+1] === '"'){ field += '"'; i++; }
      else { inQuotes = !inQuotes; }
    } else if (c === ',' && !inQuotes){
      row.push(field); field = "";
    } else if ((c === '\n' || c === '\r') && !inQuotes){
      if (c === '\r' && text[i+1] === '\n') i++;
      row.push(field); rows.push(row); field = ""; row = [];
    } else {
      field += c;
    }
  }
  if (field.length || row.length){ row.push(field); rows.push(row); }

  const head = rows.shift().map(s => s.trim());
  const objs = rows
    .filter(r => r.length && r.some(x => x !== "")) // salta righe vuote
    .map(r => {
      const obj = {};
      for (let k = 0; k < head.length; k++) obj[head[k]] = (r[k] ?? '').trim();
      obj.GW = +obj.GW || null;
      obj.PointsFor = parseNumber(obj.PointsFor);
      obj.PointsAgainst = parseNumber(obj.PointsAgainst);
      return obj;
    });

  return { head, rows: objs };
}

function parseNumber(s){
  if (s==null) return NaN;
  if (typeof s !== 'string') return Number(s);
  const t = s.replace(',', '.').trim();
  const v = parseFloat(t);
  return isNaN(v) ? NaN : v;
}

function groupBy(arr, key){
  const m = new Map();
  for(const it of arr){
    const k = it[key];
    if(!m.has(k)) m.set(k, []);
    m.get(k).push(it);
  }
  return m;
}

function lastN(arr, n){ return arr.slice(Math.max(0, arr.length - n)); }
function mean(nums){ const v = nums.filter(Number.isFinite); return v.length ? v.reduce((a,b)=>a+b,0)/v.length : 0; }
function stdDev(nums){
  const v = nums.filter(Number.isFinite);
  if(v.length<=1) return 0;
  const m = mean(v);
  const vv = mean(v.map(x => (x-m)*(x-m)));
  return Math.sqrt(vv);
}
function normalize(values){
  const finite = values.filter(Number.isFinite);
  if(!finite.length) return values.map(_=>0);
  const min = Math.min(...finite), max = Math.max(...finite);
  if (max === min) return values.map(v => Number.isFinite(v) ? 50 : 0);
  return values.map(v => Number.isFinite(v) ? ((v-min)/(max-min))*100 : 0);
}

/** Pulisce e deduplica le righe (una per Team per GW), esclude 0–0/placeholder */
function sanitizeRows(rows, phaseFilter){
  const filtered = rows.filter(r => !phaseFilter || r.Phase === phaseFilter)
    .map(r => ({
      GW: +r.GW || null,
      Team: (r.Team || '').trim(),
      Opponent: (r.Opponent || '').trim(),
      Result: (r.Result || '').trim(),
      PointsFor: parseNumber(r.PointsFor),
      PointsAgainst: parseNumber(r.PointsAgainst)
    }))
    .filter(r =>
      r.GW &&
      Number.isFinite(r.PointsFor) &&
      Number.isFinite(r.PointsAgainst) &&
      !(r.PointsFor===0 && r.PointsAgainst===0)
    );

  const seen = new Set();
  const out = [];
  for(const r of filtered){
    const key = r.Team + '|' + r.GW;
    if(!seen.has(key)){
      seen.add(key);
      out.push(r);
    }
  }
  return out;
}

/* =================== POWER RANKING =================== */
function computePower(data, phaseFilter){
  const clean = sanitizeRows(data.rows, phaseFilter);
  const byTeam = groupBy(clean, 'Team');
  const teams = Array.from(byTeam.keys()).filter(Boolean);

  const maxGW = Math.max(...clean.map(r => r.GW || 0));
  const prevGW = Number.isFinite(maxGW) ? maxGW - 1 : null;

  // Pesi dinamici: all'inizio conta più la media
  const w = (maxGW < 5)
    ? { forma: 0.2, media: 0.7, cons: 0.1 }
    : { forma: 0.5, media: 0.3, cons: 0.2 };

  function scoreAt(upToGW){
    const items = [];
    for(const team of teams){
      const series = byTeam.get(team)
        .filter(r => r.GW && r.GW <= upToGW)
        .sort((a,b)=> a.GW - b.GW);

      const pts   = series.map(s => s.PointsFor);
      const last5 = lastN(pts, 5);

      const media = mean(pts);
      const forma = mean(last5);
      const cons  = 1/(1 + stdDev(last5));

      items.push({ team, media, forma, cons });
    }
    const nForma = normalize(items.map(x=>x.forma));
    const nMedia = normalize(items.map(x=>x.media));
    const nCons  = normalize(items.map(x=>x.cons));

    return items.map((x,i)=>({
      team: x.team,
      forma: nForma[i],
      media: nMedia[i],
      cons:  nCons[i],
      score: w.forma*nForma[i] + w.media*nMedia[i] + w.cons*nCons[i]
    })).sort((a,b)=> b.score - a.score);
  }

  const now  = scoreAt(maxGW);
  const prev = prevGW>=1 ? scoreAt(prevGW) : [];

  const prevPos = new Map();
  prev.forEach((it,idx)=> prevPos.set(it.team, idx+1));

  const ranked = now.map((it,idx)=>{
    const posNow = idx+1;
    const posPrev = prevPos.get(it.team) || posNow;
    const delta = posPrev - posNow; // + = salito
    return { rank: posNow, team: it.team, score: it.score, forma: it.forma, media: it.media, cons: it.cons, delta };
  });

  return { ranked, maxGW };
}

/* =================== HALL OF SHAME / LUCKY / CURIOSITA' =================== */
function median(arr){
  const v = arr.filter(Number.isFinite).slice().sort((a,b)=>a-b);
  const n = v.length; if(!n) return 0;
  return n%2 ? v[(n-1)/2] : (v[n/2-1]+v[n/2])/2;
}

function computeHall(clean){
  const worst = clean.slice().sort((a,b)=> a.PointsFor - b.PointsFor).slice(0,10);
  const lowWins = clean.filter(r=> r.Result==='W').slice().sort((a,b)=> a.PointsFor - b.PointsFor).slice(0,10);
  const highLoss = clean.filter(r=> r.Result==='L').slice().sort((a,b)=> b.PointsFor - a.PointsFor).slice(0,10);

  // blowout/closest: consideriamo UNA riga per partita (il vincitore)
  const winners = clean.filter(r => r.PointsFor > r.PointsAgainst)
    .map(r => ({...r, margin: r.PointsFor - r.PointsAgainst, total: r.PointsFor + r.PointsAgainst}));
  const blowouts = winners.slice().sort((a,b)=> b.margin - a.margin).slice(0,5);
  const closest  = winners.slice().sort((a,b)=> a.margin - b.margin).slice(0,5);

  return { worst, lowWins, highLoss, blowouts, closest };
}

function computeLuck(clean){
  // mediana per GW su tutte le squadre
  const byGW = groupBy(clean, 'GW');
  const med = new Map();
  for (const [gw, rows] of byGW.entries()){
    med.set(+gw, median(rows.map(r=> r.PointsFor)));
  }
  // tally per team
  const tally = new Map();
  for (const r of clean){
    const m = med.get(r.GW) ?? 0;
    const isLucky   = (r.Result==='W' && r.PointsFor <  m) ? 1 : 0;
    const isUnlucky = (r.Result==='L' && r.PointsFor >  m) ? 1 : 0;
    if (!isLucky && !isUnlucky) continue;
    const rec = tally.get(r.Team) || { team:r.Team, lucky:0, unlucky:0, net:0 };
    rec.lucky   += isLucky;
    rec.unlucky += isUnlucky;
    rec.net = rec.lucky - rec.unlucky;
    tally.set(r.Team, rec);
  }
  const arr = Array.from(tally.values());
  const mostLucky   = arr.slice().sort((a,b)=> (b.net - a.net) || (b.lucky - a.lucky)).slice(0,8);
  const mostUnlucky = arr.slice().sort((a,b)=> (a.net - b.net) || (b.unlucky - a.unlucky)).slice(0,8);
  return { mostLucky, mostUnlucky, medByGW: med };
}

/* =================== RENDER SUBTABELLE =================== */
function renderTable(containerId, title, rows, cols){
  const el = document.getElementById(containerId);
  if (!el) return;
  const thead = `<thead><tr>${cols.map(c=>`<th>${c.label}</th>`).join('')}</tr></thead>`;
  const tbody = `<tbody>${
    rows.map(r => `<tr>${
      cols.map(c => `<td>${c.format? c.format(r[c.key], r): r[c.key]}</td>`).join('')
    }</tr>`).join('')
  }</tbody>`;
  el.innerHTML = `<div class="badge">${title}</div>
                  <table class="subtable">${thead}${tbody}</table>`;
}

function renderHall(h){
  renderTable('shame-worst', 'Peggiori punteggi',
    h.worst.map(r=>({gw:r.GW, team:r.Team, pf:r.PointsFor, opp:r.Opponent, pa:r.PointsAgainst})),
    [
      {key:'gw',   label:'GW'},
      {key:'team', label:'Team'},
      {key:'pf',   label:'PF', format:(v)=> v.toFixed(1)},
      {key:'opp',  label:'vs'},
      {key:'pa',   label:'PA', format:(v)=> v.toFixed(1)}
    ]);

  renderTable('shame-lowwins', 'Vittorie col punteggio più basso',
    h.lowWins.map(r=>({gw:r.GW, team:r.Team, pf:r.PointsFor, opp:r.Opponent, pa:r.PointsAgainst})),
    [
      {key:'gw',   label:'GW'},
      {key:'team', label:'Team'},
      {key:'pf',   label:'PF', format:(v)=> v.toFixed(1)},
      {key:'opp',  label:'vs'},
      {key:'pa',   label:'PA', format:(v)=> v.toFixed(1)}
    ]);

  renderTable('shame-highloss', 'Sconfitte col punteggio più alto',
    h.highLoss.map(r=>({gw:r.GW, team:r.Team, pf:r.PointsFor, opp:r.Opponent, pa:r.PointsAgainst})),
    [
      {key:'gw',   label:'GW'},
      {key:'team', label:'Team'},
      {key:'pf',   label:'PF', format:(v)=> v.toFixed(1)},
      {key:'opp',  label:'vs'},
      {key:'pa',   label:'PA', format:(v)=> v.toFixed(1)}
    ]);
}

function renderLuckBox(l){
  renderTable('luck-most', 'Top lucky / unlucky (netto)',
    [...l.mostLucky.map(x=>({...x, tag:'Lucky ▲'})), ...l.mostUnlucky.map(x=>({...x, tag:'Unlucky ▼'}))],
    [
      {key:'team',   label:'Team'},
      {key:'tag',    label:'Tipo'},
      {key:'lucky',  label:'Lucky'},
      {key:'unlucky',label:'Unlucky'},
      {key:'net',    label:'Netto'}
    ]);
}

function renderFunFacts(h){
  renderTable('fun-facts', 'Curiosità (blowout & partita più tirata)',
    [
      ...h.blowouts.map(r=>({type:'Blowout', gw:r.GW, team:r.Team, pf:r.PointsFor, opp:r.Opponent, pa:r.PointsAgainst, m:(r.PointsFor-r.PointsAgainst)})),
      ...h.closest.map (r=>({type:'Più tirata', gw:r.GW, team:r.Team, pf:r.PointsFor, opp:r.Opponent, pa:r.PointsAgainst, m:(r.PointsFor-r.PointsAgainst)}))
    ],
    [
      {key:'type', label:'Tipo'},
      {key:'gw',   label:'GW'},
      {key:'team', label:'Team'},
      {key:'pf',   label:'PF', format:(v)=> v.toFixed(1)},
      {key:'opp',  label:'vs'},
      {key:'pa',   label:'PA', format:(v)=> v.toFixed(1)},
      {key:'m',    label:'Margine', format:(v)=> v.toFixed(1)}
    ]);
}

/* =================== BOOT =================== */
(async function(){
  const urlEl = document.getElementById('csvUrl');
  const phaseEl = document.getElementById('phase');
  const btn = document.getElementById('loadBtn');
  const tbody = document.getElementById('tbody');
  const meta = document.getElementById('meta');

  const key = 'PR_CSV_URL';
  urlEl.value = localStorage.getItem(key) || DEFAULT_CSV_URL;

  async function load(){
    if(!urlEl.value) return alert("Inserisci l'URL CSV pubblicato.");
    localStorage.setItem(key, urlEl.value);
    const data = await fetchCSV(urlEl.value);

    // diagnostica (quante squadre leggo)
    const cleanForDiag = sanitizeRows(data.rows, phaseEl.value);
    const teams = Array.from(new Set(cleanForDiag.map(r => r.Team))).sort();
    document.getElementById('diag').textContent = `Squadre lette: ${teams.length} — ${teams.join(', ')}`;

    // Power Ranking
    const res = computePower(data, phaseEl.value);
    render(tbody, meta, res);

    // Sezioni extra
    const clean = sanitizeRows(data.rows, phaseEl.value); // rileggo per usare Opponent/Result
    const hall = computeHall(clean);
    renderHall(hall);

    const luck = computeLuck(clean);
    renderLuckBox(luck);

    renderFunFacts(hall);
  }

  btn.addEventListener('click', load);
  if (urlEl.value) load(); // carica automaticamente se c'è un URL
})();
</script>
</body>
</html>
